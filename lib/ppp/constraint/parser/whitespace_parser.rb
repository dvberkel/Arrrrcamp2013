# Autogenerated from a Treetop grammar. Edits may be lost.


require 'treetop'

module PPP
  module Constraint
    module Parser
      module Whitespace
        include Treetop::Runtime

        def root
          @root ||= :whitespaces
        end

        def _nt_whitespaces
          start_index = index
          if node_cache[:whitespaces].has_key?(index)
            cached = node_cache[:whitespaces][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          s0, i0 = [], index
          loop do
            r1 = _nt_whitespace
            if r1
              s0 << r1
            else
              break
            end
          end
          if s0.empty?
            @index = i0
            r0 = nil
          else
            r0 = instantiate_node(SyntaxNode,input, i0...index, s0)
          end

          node_cache[:whitespaces][start_index] = r0

          r0
        end

        def _nt_whitespace
          start_index = index
          if node_cache[:whitespace].has_key?(index)
            cached = node_cache[:whitespace][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          i0 = index
          r1 = _nt_newline
          if r1
            r0 = r1
          else
            r2 = _nt_tab
            if r2
              r0 = r2
            else
              r3 = _nt_space
              if r3
                r0 = r3
              else
                @index = i0
                r0 = nil
              end
            end
          end

          node_cache[:whitespace][start_index] = r0

          r0
        end

        def _nt_newline
          start_index = index
          if node_cache[:newline].has_key?(index)
            cached = node_cache[:newline][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?("\n", false, index)
            r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("\n")
            r0 = nil
          end

          node_cache[:newline][start_index] = r0

          r0
        end

        def _nt_tab
          start_index = index
          if node_cache[:tab].has_key?(index)
            cached = node_cache[:tab][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?("\t", false, index)
            r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure("\t")
            r0 = nil
          end

          node_cache[:tab][start_index] = r0

          r0
        end

        def _nt_space
          start_index = index
          if node_cache[:space].has_key?(index)
            cached = node_cache[:space][index]
            if cached
              cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
              @index = cached.interval.end
            end
            return cached
          end

          if has_terminal?(' ', false, index)
            r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
            @index += 1
          else
            terminal_parse_failure(' ')
            r0 = nil
          end

          node_cache[:space][start_index] = r0

          r0
        end

      end

      class WhitespaceParser < Treetop::Runtime::CompiledParser
        include Whitespace
      end

    end
  end
end
